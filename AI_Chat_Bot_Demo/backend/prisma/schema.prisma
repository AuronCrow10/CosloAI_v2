generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(uuid())
  email          String   @unique
  passwordHash   String?
  googleId       String?  @unique
  role           UserRole @default(CLIENT)
  emailVerified  Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // NEW
  name       String?
  avatarUrl  String?

  bots             Bot[]
  refreshTokens    RefreshToken[]
  emailTokens      EmailVerificationToken[]
  metaSessions     MetaConnectSession[]
  whatsappSessions WhatsappConnectSession[]

  openaiUsages     OpenAIUsage[]
}

enum UserRole {
  ADMIN
  CLIENT
}

model Bot {
  id                     String       @id @default(uuid())
  userId                 String
  user                   User         @relation(fields: [userId], references: [id])
  slug                   String       @unique
  name                   String
  description            String?
  systemPrompt           String
  knowledgeClientId      String?
  domain                 String?
  useDomainCrawler       Boolean      @default(false)
  usePdfCrawler          Boolean      @default(false)
  channelWeb             Boolean      @default(true)
  channelWhatsapp        Boolean      @default(false)
  channelInstagram       Boolean      @default(false)
  channelMessenger       Boolean      @default(false)
  useCalendar            Boolean      @default(false)
  calendarId             String?
  timeZone               String?
  defaultDurationMinutes Int?         @default(30)
  status                 BotStatus    @default(DRAFT)
  createdAt              DateTime     @default(now())
  updatedAt              DateTime     @updatedAt

  channels         BotChannel[]
  subscription     Subscription?
  conversations    Conversation[]
  payments         Payment[]
  metaSessions     MetaConnectSession[]
  whatsappSessions WhatsappConnectSession[]

  openaiUsages     OpenAIUsage[]
}

enum BotStatus {
  DRAFT
  PENDING_PAYMENT
  ACTIVE
  SUSPENDED
  CANCELED
}

model BotChannel {
  id          String       @id @default(uuid())
  botId       String
  bot         Bot          @relation(fields: [botId], references: [id])
  type        ChannelType
  externalId  String
  accessToken String
  meta        Json?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([botId])
  @@index([type, externalId])
  @@unique([botId, type, externalId], name: "botId_type_externalId")
}

enum ChannelType {
  WEB
  WHATSAPP
  FACEBOOK
  INSTAGRAM
}

model Subscription {
  id                   String               @id @default(uuid())
  botId                String               @unique
  bot                  Bot                  @relation(fields: [botId], references: [id])
  stripeCustomerId     String
  stripeSubscriptionId String
  stripePriceId        String               // kept for backwards compatibility (first / primary price)
  status               SubscriptionStatus
  currency             String?
  planSnapshotJson     Json?
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt

  // selected usage plan for this bot
  usagePlanId          String?
  usagePlan            UsagePlan?           @relation(fields: [usagePlanId], references: [id])
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

model Conversation {
  id             String       @id @default(uuid())
  botId          String
  bot            Bot          @relation(fields: [botId], references: [id])
  channel        ChannelType
  externalUserId String
  lastMessageAt  DateTime     @default(now())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  messages       Message[]

  @@unique([botId, channel, externalUserId], name: "botId_channel_externalUserId")
}

model Message {
  id               String       @id @default(uuid())
  conversationId   String
  conversation     Conversation @relation(fields: [conversationId], references: [id])
  role             MessageRole
  content          String
  channelMessageId String?
  createdAt        DateTime     @default(now())

  @@index([conversationId])
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
}

model EmailVerificationToken {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
}

//
// DB-driven feature pricing (LEGACY – still there, but we’ll move to plans)
//
model FeaturePrice {
  id                 String   @id @default(uuid())
  code               String   @unique  // e.g. "DOMAIN_CRAWLER", "PDF_CRAWLER", etc.
  label              String
  monthlyAmountCents Int
  currency           String
  stripePriceId      String?
  isActive           Boolean  @default(true)

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
}

//
// Usage-based plan definition (per bot)
//
model UsagePlan {
  id           String   @id @default(uuid())
  code         String   @unique   // e.g. "STARTER", "GROWTH", "SCALE", "CUSTOM"
  name         String
  description  String?

  // Token limit per month (for all operations combined).
  // Null = no limit (or “unlimited”).
  monthlyTokens Int?

  // Billing info
  monthlyAmountCents Int
  currency           String
  stripePriceId      String?  // Stripe recurring price ID for this plan

  isActive           Boolean  @default(true)

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  subscriptions      Subscription[]
}

//
// Legal payment / invoice log
//
model Payment {
  id                    String   @id @default(uuid())

  botId                 String
  bot                   Bot      @relation(fields: [botId], references: [id])

  stripeCustomerId      String
  stripeSubscriptionId  String?
  stripeInvoiceId       String?
  stripePaymentIntentId String?

  amountCents           Int
  currency              String
  status                String

  billingEmail          String?
  billingName           String?
  billingAddressJson    Json?

  periodStart           DateTime?
  periodEnd             DateTime?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

model MetaConnectSession {
  id                 String      @id @default(uuid())
  botId              String
  bot                Bot         @relation(fields: [botId], references: [id])
  userId             String
  user               User        @relation(fields: [userId], references: [id])
  channelType        ChannelType
  pagesJson          Json
  longLivedUserToken String
  createdAt          DateTime    @default(now())

  @@index([botId])
  @@index([userId])
  @@index([createdAt])
}

model WhatsappConnectSession {
  id               String   @id @default(uuid())
  botId            String
  bot              Bot      @relation(fields: [botId], references: [id])
  userId           String
  user             User     @relation(fields: [userId], references: [id])
  wabaId           String
  phoneNumbersJson Json
  waAccessToken    String
  createdAt        DateTime @default(now())

  @@index([botId])
  @@index([userId])
  @@index([createdAt])
}

model OpenAIUsage {
  id               String   @id @default(uuid())
  userId           String?
  user             User?    @relation(fields: [userId], references: [id])
  botId            String?
  bot              Bot?     @relation(fields: [botId], references: [id])

  model            String
  operation        String

  promptTokens     Int
  completionTokens Int
  totalTokens      Int

  createdAt        DateTime @default(now())

  @@index([userId, createdAt])
  @@index([botId, createdAt])
}
